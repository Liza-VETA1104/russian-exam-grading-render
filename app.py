# -*- coding: utf-8 -*-
"""Untitled2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1yzN4u6OnmWG_nZ-HNdtLMTdysmYAk6sL
"""

import pandas as pd
import numpy as np
import re
import joblib
from scipy.sparse import hstack, csr_matrix
import gradio as gr
import os

# === Загрузка моделей ===
tfidf = joblib.load('tfidf_vectorizer.pkl')
scaler = joblib.load('feature_scaler.pkl')
model_q1 = joblib.load('model_q1.pkl')
model_q2 = joblib.load('model_q2.pkl')
model_q3 = joblib.load('model_q3.pkl')

# Новая модель для вопроса 4
model_q4 = joblib.load('model_q4_enhanced.pkl')
tfidf_q4 = joblib.load('tfidf_q4.pkl')
scaler_q4 = joblib.load('scaler_q4.pkl')

# === Функции обработки ===
def clean_html(text):
    clean = re.compile('<.*?>')
    return re.sub(clean, ' ', str(text)).replace('  ', ' ').strip()

def remove_instruction(transcript, q_num):
    if q_num == 1: start_phrase = "Начинайте свой диалог."
    elif q_num == 2: start_phrase = "Ответьте на вопросы собеседника полными предложениями."
    elif q_num == 3: start_phrase = "Поблагодарите за предоставленную информацию."
    elif q_num == 4: start_phrase = "Когда будете готовы, можете начинать описывать."
    else: return transcript
    idx = transcript.find(start_phrase)
    return transcript[idx + len(start_phrase):].strip() if idx != -1 else transcript

def extract_features(text):
    sentences = re.split(r'[.!?]+', text)
    n_sents = len([s for s in sentences if len(s.strip()) > 0])
    words = text.split()
    n_words = len(words)
    avg_sent_len = n_words / n_sents if n_sents > 0 else 0
    return [n_sents, n_words, avg_sent_len, int('?' in text)]

def get_q4_features_enhanced(text):
    text_low = text.lower()
    return {
        'has_season': int(any(w in text_low for w in ['лето', 'зима', 'весна', 'осень', 'тёплое время', 'снег', 'дождь'])),
        'has_place': int(any(w in text_low for w in ['кухня', 'дом', 'парк', 'вокзал', 'река', 'улица'])),
        'has_people_count': int(any(w in text_low for w in ['один', 'два', 'три', 'четыре', 'много детей', 'целая семья'])),
        'has_family': int(any(w in text_low for w in ['в нашей семье', 'у меня трое детей', 'я старшая', 'мой брат'])),
        'has_hobby': int(any(w in text_low for w in ['люблю готовить', 'играю в футбол', 'гуляю на природе', 'вышиваю'])),
        'n_sentences': len(re.split(r'[.!?]+', text)),
        'is_structured': int(len(re.findall(r'\b(на картинке|изображено|я вижу|расскажу о)\b', text_low)) >= 1),
        'has_emotion': int(any(w in text_low for w in ['радостный', 'счастлив', 'улыбается', 'весело'])),
        'is_garbage': int(any(w in text_low for w in [
            'characterization', 'leather.ru', 'Feit', 'Паспортный канал', 'understanding'
        ]) or len(text.split()) < 3)
    }

# === Основная функция ===
def grade_exam(file):
    df = pd.read_csv(file.name, sep=';', on_bad_lines='skip')

    if 'Оценка экзаменатора' in df.columns:
        df = df.drop(columns=['Оценка экзаменатора'])

    required_cols = ['Id экзамена', 'Id вопроса', '№ вопроса', 'Текст вопроса',
                     'Картинка из вопроса', 'Транскрибация ответа', 'Ссылка на оригинальный файл запис']
    for col in required_cols:
        if col not in df.columns:
            raise ValueError(f"Отсутствует колонка: {col}")

    df['Текст вопроса_clean'] = df['Текст вопроса'].apply(clean_html)
    df['cleaned_transcript'] = df.apply(
        lambda row: remove_instruction(row['Транскрибация ответа'], row['№ вопроса']),
        axis=1
    )
    df['combined_text'] = df['Текст вопроса_clean'] + ' [SEP] ' + df['cleaned_transcript'].fillna('')

    y_pred = np.zeros(len(df), dtype=int)

    for q_num in [1, 2, 3, 4]:
        mask = df['№ вопроса'] == q_num
        if not mask.any():
            continue

        if q_num == 4:
            X_text = tfidf_q4.transform(df.loc[mask, 'combined_text'])
            ling_feat = np.array([extract_features(txt) for txt in df.loc[mask, 'cleaned_transcript'].fillna('')])
            ling_scaled = scaler_q4.transform(ling_feat)
            feats = df.loc[mask, 'cleaned_transcript'].apply(get_q4_features_enhanced)
            feature_cols = list(feats.iloc[0].keys())
            checklist_feat = np.array([list(f.values()) for f in feats])
            X = hstack([X_text, csr_matrix(ling_scaled), csr_matrix(checklist_feat)])
            pred_raw = model_q4.predict(X)
            pred_rounded = np.array([int(np.clip(round(p), 0, 2)) for p in pred_raw])
            pred_rounded[checklist_feat[:, -1] == 1] = 0
            y_pred[mask] = pred_rounded
        else:
            X_text = tfidf.transform(df.loc[mask, 'combined_text'])
            ling_feat = np.array([extract_features(txt) for txt in df.loc[mask, 'cleaned_transcript'].fillna('')])
            ling_scaled = scaler.transform(ling_feat)
            q_norm = np.full((mask.sum(), 1), q_num / 4.0)
            X = hstack([X_text, csr_matrix(q_norm), csr_matrix(ling_scaled)])
            model = {1: model_q1, 2: model_q2, 3: model_q3}[q_num]
            pred_raw = model.predict(X)
            if q_num in (1, 3):
                pred_rounded = np.array([0 if p < 0.5 else 1 for p in pred_raw])
            else:
                pred_rounded = np.array([int(np.clip(round(p), 0, 2)) for p in pred_raw])
            y_pred[mask] = pred_rounded

    df['Оценка экзаменатора'] = y_pred
    output_cols = ['Id экзамена', 'Id вопроса', '№ вопроса', 'Текст вопроса',
                   'Картинка из вопроса', 'Оценка экзаменатора',
                   'Транскрибация ответа', 'Ссылка на оригинальный файл запис']
    df = df[output_cols]

    output_path = '/tmp/graded_output.csv'
    df.to_csv(output_path, index=False, sep=';')
    return output_path

# === Запуск ===
iface = gr.Interface(
    fn=grade_exam,
    inputs=gr.File(label="Загрузите CSV с экзаменационными данными"),
    outputs=gr.File(label="Скачать результат с оценками"),
    title="Автоматическая оценка устного экзамена по русскому языку (v2)",
    description="MAE = 0.0397 • Загрузите файл в формате CSV с разделителем ';'"
)

if __name__ == "__main__":
    iface.launch(server_name="0.0.0.0"))
